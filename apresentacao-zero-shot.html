<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Apresentação | Categorização Zero-Shot</title>
  <style>
    :root {
      --bg: #0b1021;
      --card: rgba(255, 255, 255, 0.04);
      --card-border: rgba(255, 255, 255, 0.08);
      --accent: #76c7c0;
      --accent-2: #7c5dfa;
      --text: #e9edf5;
      --muted: #b9c2d0;
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(124, 93, 250, 0.12), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(118, 199, 192, 0.14), transparent 30%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
      padding-bottom: 64px;
    }

    .container {
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 18px;
    }

    header {
      padding: 56px 0 28px;
    }

    .eyebrow {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-weight: 700;
      letter-spacing: 0.4px;
      color: #dfe4ee;
    }

    .hero {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 32px;
      align-items: center;
    }

    h1 {
      margin: 16px 0 12px;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: -0.5px;
    }

    p.lead {
      font-size: 1.05rem;
      color: var(--muted);
      margin: 0 0 16px;
      max-width: 720px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    .chip {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: 0.95rem;
      color: #e3e8f0;
    }

    .hero-card {
      background: linear-gradient(135deg, rgba(118, 199, 192, 0.12), rgba(124, 93, 250, 0.12));
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 18px;
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .hero-card strong { color: #fff; font-size: 1.1rem; }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 14px;
      margin-top: 18px;
    }

    .stat {
      background: var(--card);
      border: 1px solid var(--card-border);
      border-radius: 14px;
      padding: 14px;
      text-align: center;
    }

    .stat .number { font-size: 1.8rem; font-weight: 700; color: #fff; }

    section { margin-top: 28px; }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .card h2 { margin-top: 0; letter-spacing: -0.3px; }

    .card p, .card li { color: var(--muted); }

    .timeline {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }

    .step {
      border-left: 3px solid var(--accent);
      padding-left: 12px;
    }

    .tag {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(124, 93, 250, 0.18);
      color: #f0ecff;
      border: 1px solid rgba(124, 93, 250, 0.35);
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .demo-area {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 18px;
      margin-top: 14px;
      align-items: start;
    }

    .stack { display: grid; gap: 10px; }

    label { font-weight: 700; }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: #fff;
      font-size: 1rem;
      resize: vertical;
    }

    textarea::placeholder { color: rgba(233, 237, 245, 0.6); }

    button {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #0b1021;
      border: none;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(124, 93, 250, 0.35);
      transition: transform 0.1s ease, opacity 0.15s ease;
      width: fit-content;
    }

    button:hover { opacity: 0.92; transform: translateY(-1px); }

    .result {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 16px;
      min-height: 200px;
    }

    .result h3 { margin-top: 0; }

    .candidates {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }

    .candidate {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 12px;
    }

    code {
      background: rgba(255, 255, 255, 0.08);
      padding: 2px 6px;
      border-radius: 6px;
      color: #f7f9ff;
    }

    @media (max-width: 860px) {
      .hero, .demo-area { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header class="container">
    <div class="hero">
      <div>
        <div class="eyebrow">Trabalho de IA · Zero-shot Classification</div>
        <h1>Categorização Automática de Produtos</h1>
        <p class="lead">Interface pronta para apresentações: cards, destaques e uma demo estática que mostra o pipeline de limpeza
          e categorização sem depender de backend.</p>
        <div class="chips">
          <span class="chip">Hugging Face NLI</span>
          <span class="chip">Pipeline zero-shot</span>
          <span class="chip">Exploração offline</span>
        </div>
      </div>
      <div class="hero-card">
        <strong>Resumo executivo</strong>
        <p class="lead">Lê descrições sujas de itens, expande abreviações e sugere categorias padronizadas com base em um modelo
          multilíngue de inferência textual.</p>
        <div class="stats">
          <div class="stat">
            <div class="number">8</div>
            <div class="muted">Categorias principais</div>
          </div>
          <div class="stat">
            <div class="number">200</div>
            <div class="muted">itens avaliados no JSON demo</div>
          </div>
          <div class="stat">
            <div class="number">100%</div>
            <div class="muted">processamento offline</div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="grid">
      <div class="card">
        <h2>Problema</h2>
        <p>Descrições em CSV chegam abreviadas e inconsistentes, dificultando agrupamento, catálogo e logística.</p>
        <ul>
          <li>Coluna <code>itens</code> suja e heterogênea.</li>
          <li>Erros de digitação e siglas internas.</li>
          <li>Classificação manual custosa.</li>
        </ul>
      </div>
      <div class="card">
        <h2>Público-alvo</h2>
        <ul>
          <li>Gestores de catálogo e marketplace.</li>
          <li>Equipes de governança e dados.</li>
          <li>Times de logística e compras.</li>
        </ul>
      </div>
      <div class="card">
        <h2>Abordagem</h2>
        <ul>
          <li>Zero-Shot Classification (NLI) sem dataset anotado.</li>
          <li>Expansão de abreviações + normalização de texto.</li>
          <li>Top 3 rótulos, distribuição completa e palavras-chave.</li>
        </ul>
      </div>
      <div class="card">
        <h2>Dados &amp; Modelo</h2>
        <ul>
          <li>Fontes: <code>pedidos.csv</code> e <code>produtos.csv</code>.</li>
          <li>Pipeline <code>zero-shot-classification</code> (ex.: <code>facebook/bart-large-mnli</code>).</li>
          <li>Resultados exportados em <code>public/demo_results.json</code>.</li>
        </ul>
      </div>
    </section>

    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
        <h2 style="margin:0;">Fluxo de dados</h2>
        <span class="tag">Pipeline explicado</span>
      </div>
      <div class="timeline">
        <div class="step">
          <h3>1. Entrada</h3>
          <p>Leitura de <code>pedidos.csv</code> e <code>produtos.csv</code>; fallback para exemplos internos.</p>
        </div>
        <div class="step">
          <h3>2. Limpeza</h3>
          <p>Expansão de abreviações (<code>liq</code> → liquidificador), remoção de ruído e extração de palavras-chave.</p>
        </div>
        <div class="step">
          <h3>3. Zero-shot</h3>
          <p>Modelo NLI compara descrição legível com 8 categorias principais, retornando distribuição de scores.</p>
        </div>
        <div class="step">
          <h3>4. Exportação</h3>
          <p>Resultados salvos em <code>public/demo_results.json</code> para serem consumidos pela interface.</p>
        </div>
      </div>
    </section>

    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
        <h2 style="margin:0;">Demo estática</h2>
        <span class="tag">Sem backend</span>
      </div>
      <p class="muted">Digite um texto, clique em "Classificar" e veja o exemplo mais próximo salvo em <code>public/demo_results.json</code>,
        gerado previamente pelo script <code>gerar_demo_zero_shot.py</code>. A interface mantém a área de classificação para validar
        o fluxo.</p>

      <div class="demo-area">
        <div class="stack">
          <label for="dirty-text">Descrição suja</label>
          <textarea id="dirty-text" placeholder="Ex.: LIQ. IND. 4LTS LQL4"></textarea>
          <button id="classify-btn">Classificar</button>
        </div>
        <div id="result" class="result" aria-live="polite">
          <h3>Categoria prevista</h3>
          <p class="muted">Insira um texto e veja a predição e a descrição legível.</p>
        </div>
      </div>
    </section>
  </main>

  <script>
    const resultBox = document.getElementById('result');
    const inputEl = document.getElementById('dirty-text');
    const candidatesCache = { data: [] };

    function normalize(text) {
      return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function buildSearchFields(item) {
      const keywords = (item.detalhes?.palavras_chave || []).join(' ');
      return [
        item.texto || '',
        item.descricao_legivel || '',
        keywords,
      ]
        .map(normalize)
        .filter(Boolean);
    }

    function levenshteinDistance(a, b) {
      const lenA = a.length;
      const lenB = b.length;
      const dp = Array.from({ length: lenA + 1 }, (_, i) => [i, ...Array(lenB).fill(0)]);
      for (let j = 0; j <= lenB; j++) dp[0][j] = j;
      for (let i = 1; i <= lenA; i++) {
        for (let j = 1; j <= lenB; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost,
          );
        }
      }
      return dp[lenA][lenB];
    }

    function tokenSimilarity(queryTokens, fieldTokens) {
      if (!queryTokens.length || !fieldTokens.length) return 0;
      const bestMatches = queryTokens.map((qt) => {
        const scores = fieldTokens.map((ft) => {
          const dist = levenshteinDistance(qt, ft);
          const maxLen = Math.max(qt.length, ft.length) || 1;
          return 1 - dist / maxLen;
        });
        return Math.max(...scores);
      });
      return bestMatches.reduce((sum, s) => sum + s, 0) / bestMatches.length;
    }

    function scoreField(normField, normQuery, words) {
      if (normField === normQuery) return 2;
      if (normField.includes(normQuery) || normQuery.includes(normField)) return 1.5;

      const fieldTokens = normField.split(' ').filter(Boolean);
      const tokenScore = tokenSimilarity(words, fieldTokens);
      const hits = words.filter((w) => normField.includes(w)).length;
      const partialScore = words.length ? hits / words.length : 0;

      return Math.max(tokenScore, partialScore);
    }

    function bestLocalMatch(query) {
      if (!candidatesCache.data.length) return null;
      const normQuery = normalize(query);
      const words = normQuery.split(' ').filter(Boolean);
      let best = null;

      candidatesCache.data.forEach((item) => {
        const searchFields = buildSearchFields(item);
        const fieldScore = searchFields.reduce((max, field) => Math.max(max, scoreField(field, normQuery, words)), 0);
        if (!best || fieldScore > best.score) {
          best = { item, score: fieldScore };
        }
      });

      return best && best.score > 0.1 ? best.item : null;
    }

    function renderResult(item, query) {
      if (!item) {
        resultBox.innerHTML = `<h3>Sem correspondência direta</h3><p class="muted">Não encontramos esse texto no JSON demo. Ajuste a descrição ou adicione novos exemplos em <code>public/demo_results.json</code>.</p>`;
        return;
      }
      const candidates = (item.candidatas || []).map((c) => `<div class="candidate"><strong>${c.label}</strong><br/><span class="muted">Score: ${(c.score * 100).toFixed(1)}%</span></div>`).join('');
      const keywords = (item.detalhes?.palavras_chave || []).join(', ') || '—';
      const normalized = item.detalhes?.texto_normalizado || '—';
      const distribution = (item.detalhes?.scores_por_categoria || [])
        .map((c) => `<li>${c.label}: ${(c.score * 100).toFixed(1)}%</li>`)
        .join('');
      const guidingQuestions = (item.detalhes?.perguntas_sugeridas || [])
        .map((q) => `<li>${q}</li>`)
        .join('');
      resultBox.innerHTML = `
        <h3>Categoria prevista</h3>
        <p><strong>${item.categoria}</strong></p>
        <p class="muted">Score: ${(item.score * 100).toFixed(1)}% • Texto consultado: "${query}"</p>
        <h4>Top 3 candidatas</h4>
        <div class="candidates">${candidates}</div>
        <h4>Descrição legível</h4>
        <p>${item.descricao_legivel || '—'}</p>
        <h4>Palavras-chave e normalização</h4>
        <p class="muted">Normalizado: <code>${normalized}</code></p>
        <p>Termos: ${keywords}</p>
        <h4>Distribuição completa</h4>
        <ul class="muted">${distribution}</ul>
        <h4>Perguntas para explorar</h4>
        <ul>${guidingQuestions}</ul>
      `;
    }

    async function loadDemoData() {
      const response = await fetch('./public/demo_results.json');
      const data = await response.json();
      candidatesCache.data = data;
    }

    document.getElementById('classify-btn').addEventListener('click', () => {
      const query = inputEl.value.trim();
      if (!query) {
        resultBox.innerHTML = `<h3>Informe uma descrição</h3><p class="muted">Digite um texto na caixa acima para localizar o exemplo mais próximo no JSON demo.</p>`;
        return;
      }
      const match = bestLocalMatch(query);
      renderResult(match, query);
    });

    loadDemoData();
  </script>
</body>
</html>
